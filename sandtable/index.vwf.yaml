# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

--- 
extends: http://vwf.example.com/navtouch.vwf
type: model/x-glge
properties:
  ambientColor: [ 183, 183, 183 ]
  backgroundColor: [ 135, 196, 250 ]
  lineWidth: 32
  lineColor: [ 0, 0, 0 ]
  lineHeight: 100
  objScale: 200
  minDrawDistance: 200    
  inputMode: 
    set: |
      switch( value ) {
        case "orbit":
        case "draw":
        case "pindrop":
          this.inputMode = value;
          if ( value == "orbit" ) {
            this.navmode = "orbit";
          } else {
            this.navmode = "none";
          }          
          break;
        default:
          this.logger.debug( "WARNING: orbit, draw, and pindrop are the only supported inputMode" );
          break;
      } //@ sourceURL=inputMode.set
    value: "orbit"
  translationSpeed: 40.0
  nodesCreated: 
  lineIndex: 1
  cubeIndex: 1
  coneIndex: 1
  pushpinIndex: 1
methods:
  initializeCamera:
  initializeInputMode:
  clear: |
    if ( this.nodesCreated ) {
      for ( var i = 0; i < this.nodesCreated.length; i++ ){
        this.children.delete( this.getChild(this.nodesCreated[i]) );
      }
      this.nodesCreated = [];  
    }
  draw:
  pindrop:
children:
  toolbar:
    properties:
      selectedColor:
        set: |
          this.selectedColor = value;
          this.selectedColorChanged( value );
        value:
          "black"
    methods:
      clear: |
        this.clearing();
    events:
      selectedColorChanged:
      clearing:
  flat_terrain:
    extends: http://vwf.example.com/node3.vwf
    source: models/vwf_terrain.dae
    type: model/vnd.collada+xml
    properties:
      translation: [ 0, 0, -150 ]
      scale: [ 0.008, 0.008, 0.020 ]
  sceneCenter:
    extends: http://vwf.example.com/node3.vwf
  light1:
    extends: http://vwf.example.com/light.vwf
    implements:
    - http://vwf.example.com/glgeLight.vwf
    properties:
      lightType: "point"
      enable: true
      distance: 2000
      intensity: 3
      color: [ 255, 255, 255 ]
      glge-constantAttenuation: 0.3
      glge-linearAttenuation: 0.00000001
      glge-quadraticAttenuation: 0.0000001  
  predator1:
    extends: http://vwf.example.com/node3.vwf 
    methods:
      animate: 
    scripts:
      - |
          this.initialize = function() {

            this.path = [];
            var len = 0, pos, x, y, z = 1200;

            for ( var theta = 0; theta < 2 * Math.PI && len < (( 2*180 )-1); theta += Math.PI / 180 ) {
              x = 10000 * Math.cos( theta );
              y = 10000 * Math.sin( theta );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { translation: pos, time: 1 } );
            }
            this.nextPathIndex = ( this.lastPathIndex || 0 ) + 1;
            this.timeSinceLast = this.time;
            this.planeGroup1.translation = this.path[ this.lastPathIndex || 0 ].translation;
            this.goal1.translation = this.path[ this.nextPathIndex || 0 ].translation;

            this.animating = true;
          }
          this.animate = function() {
            var time = this.time;
            var len = this.path.length;
            var timeElasped = time - this.timeSinceLast;
            var lastPathPoint = this.path[ this.lastPathIndex ];
            var nextPathPoint = this.path[ this.nextPathIndex ];
            var goalPointIndex = this.nextPathIndex + 1;
            if ( goalPointIndex >= this.path.length )
              goalPointIndex = 0;
            var goalPathPoint = this.path[ goalPointIndex ];
            var percentDone = timeElasped / nextPathPoint.time;
            if ( percentDone > 0.975 )
              percentDone = 1;
             
            function interpolate( beforeCoord, afterCoord, percent ) {
              return beforeCoord + percent * (afterCoord - beforeCoord);
            }
            
            var newX = interpolate( nextPathPoint.translation[0], goalPathPoint.translation[0], percentDone );
            var newY = interpolate( nextPathPoint.translation[1], goalPathPoint.translation[1], percentDone );
            this.goal1.translation = [ newX, newY, 1200 ]; 
            
            newX = interpolate( lastPathPoint.translation[0], nextPathPoint.translation[0], percentDone );
            newY = interpolate( lastPathPoint.translation[1], nextPathPoint.translation[1], percentDone );
            this.planeGroup1.translation = [ newX, newY, 1200 ];
            
            var zRot = [ goalPathPoint.translation[0] - newX, goalPathPoint.translation[1] - newY, 0 ];
            this.planeGroup1.rotation = [ 0, 0, 1, (Math.atan2( zRot[1], zRot[0] )-(Math.PI*0.5)) * 180 / Math.PI ]; 
            
            if ( percentDone == 1 ) {
              this.lastPathIndex += 1;
              this.timeSinceLast = time;
            }
            if ( this.animating ) {
              this.future( 0.1 ).animate();
            } 		  
          } //@ sourceURL=predator1.vwf
    properties:
      translation: [ 0, 0, 1200 ]
      lastPathIndex:
        set: |
          if ( value >= 0 ) {
            if ( this.path && value < this.path.length ) {
              this.lastPathIndex = value;
              this.nextPathIndex = value+1;
              if ( this.nextPathIndex == this.path.length )
                this.nextPathIndex = 0;
            } else {
              this.lastPathIndex = 0;
              this.nextPathIndex = 1;              
            }
          }
        value: 0
      nextPathIndex: 0
      timeSinceLast: 0
      animating:
        set: |
          if ( value && !this.animating ) {
             this.future( 0.1 ).animate();
          }
          this.animating = value;
        value: false
    children:
      goal1:
        extends: http://vwf.example.com/node3.vwf 
        properties:
          translation: [ 0, 0, 1200 ]
      planeGroup1:
        extends: http://vwf.example.com/node3.vwf 
        properties:
          translation: [ 0, 0, 1200 ]
        children:
          plane1:
            extends: http://vwf.example.com/node3.vwf
            source: models/Predator.dae
            type: model/vnd.collada+xml
            properties:
              translation: [ 0, 500, 1800 ]
              scale: [ 15, 15, 15 ]
          cone1:
            extends: http://vwf.example.com/node3.vwf
            source: models/cone.dae
            type: model/vnd.collada+xml
            properties:
              translation: [ 0, -300, -1100 ]
              scale: [ 8, 8, 16 ]
  predator2:
    extends: http://vwf.example.com/node3.vwf 
    methods:
      animate:
    scripts:
    - |
        this.initialize = function() {
          console.info( "================ predator2 ================" );

          this.path = [];
          var len, pos, x = 0, y = 0, z = 12000;
          var radius = 5000;
          var step = 200;

          y = 0;
          for ( var x = radius - 200; x > -radius; x -= step ) {
            pos = [ x, 0, 1200 ];
            len = this.path.length;
            this.path.push( { translation: pos, time: 1 } );
          }

          for ( var theta = 1.5 * Math.PI; theta > 0; theta -= Math.PI / 90 ) {
            x = -radius + ( radius * Math.cos( theta ) );
            y = radius + ( radius * Math.sin( theta ) );
            len = this.path.length;
            pos = [ x, y, z ];
            this.path.push( { translation: pos, time: 2 } );
          } 

          x = 0;
          for ( var y = radius - step; y > -radius ; y -= step ) {
            pos = [ 0, y, 1200 ];
            len = this.path.length;
            this.path.push( { translation: pos, time: 1 } );
          }

          for ( var theta = 2 * Math.PI; theta > 0.5 * Math.PI; theta -= Math.PI / 90 ) {
            x = -radius + (radius * Math.cos( theta ) );
            y = -radius + (radius * Math.sin( theta ) );
            len = this.path.length;
            pos = [ x, y, z ];
            this.path.push( { translation: pos, time: 2 } );
          } 

          y = 0;
          for ( var x = -radius + step; x < radius; x += step ) {
            pos = [ x, 0, 1200 ];
            len = this.path.length;
            this.path.push( { translation: pos, time: 1 } );
          }            

          for ( var theta = 1.5 * Math.PI; theta < 3.0 * Math.PI; theta += Math.PI / 90 ) {
            x = radius + (radius * Math.cos( theta ) );
            y = radius + (radius * Math.sin( theta ) );
            len = this.path.length;
            pos = [ x, y, z ];
            this.path.push( { translation: pos, time: 2 } );
          }
          
          x = 0;
          for ( var y = radius - step; y > -radius; y -= step ) {
            pos = [ 0, y, 1200 ];
            len = this.path.length;
            this.path.push( { translation: pos, time: 1 } );
          }

          for ( var theta = 1.0 * Math.PI; theta < 2.5 * Math.PI; theta += Math.PI / 90 ) {
            x = radius + ( radius * Math.cos( theta ) );
            y = -radius + ( radius * Math.sin( theta ) );
            len = this.path.length;
            pos = [ x, y, z ];
            this.path.push( { translation: pos, time: 2 } );
          }            
         
          this.nextPathIndex = ( this.lastPathIndex || 0 ) + 1;
          this.timeSinceLast = this.time;
          this.planeGroup2.translation = this.path[ this.lastPathIndex || 0 ].translation;
          this.goal2.translation = this.path[ this.nextPathIndex || 0 ].translation;
          
          this.animating = true;
        }
        this.animate = function() {
          var time = this.time;
          var len = this.path.length;
          var timeElasped = time - this.timeSinceLast;
          var lastPathPoint = this.path[ this.lastPathIndex ];
          var nextPathPoint = this.path[ this.nextPathIndex ];
          var goalPointIndex = this.nextPathIndex + 1;
          if ( goalPointIndex >= this.path.length )
            goalPointIndex = 0;
          var goalPathPoint = this.path[ goalPointIndex ];
          var percentDone = timeElasped / nextPathPoint.time;
          if ( percentDone > 0.975 )
            percentDone = 1;
        
          function interpolate( beforeCoord, afterCoord, percent ) {
            return beforeCoord + percent * (afterCoord - beforeCoord);
          }
          var newX = interpolate( nextPathPoint.translation[0], goalPathPoint.translation[0], percentDone );
          var newY = interpolate( nextPathPoint.translation[1], goalPathPoint.translation[1], percentDone );
          this.goal2.translation = [ newX, newY, 1200 ]; 
          
          newX = interpolate( lastPathPoint.translation[0], nextPathPoint.translation[0], percentDone );
          newY = interpolate( lastPathPoint.translation[1], nextPathPoint.translation[1], percentDone );
          this.planeGroup2.translation = [ newX, newY, 1200 ];

          var zRot = [ goalPathPoint.translation[0] - newX, goalPathPoint.translation[1] - newY, 0 ];
          this.planeGroup2.rotation = [ 0, 0, 1, (Math.atan2( zRot[1], zRot[0] )-(Math.PI*0.5)) * 180 / Math.PI ];

          if ( percentDone == 1 ) {
            this.lastPathIndex += 1;
            var newPt = this.path[ this.lastPathIndex ].translation;
            var goalPt = this.path[ this.nextPathIndex ].translation;
            this.timeSinceLast = time;
          }
          if ( this.animating ) {
            this.future( 0.1 ).animate();
          }          
        } //@ sourceURL=predator2.vwf
    properties:
      translation: [ 0, 0, 1500 ]
      lastPathIndex:
        set: |

          if ( value >= 0 ) {
            if ( this.path && value < this.path.length ) {
              this.lastPathIndex = value;
              this.nextPathIndex = value+1;
              if ( this.nextPathIndex == this.path.length )
                this.nextPathIndex = 0;
            } else {
              this.lastPathIndex = 0;
              this.nextPathIndex = 1;
            }
          }
        value: 0
      nextPathIndex: 0
      timeSinceLast: 0
      animating:
        set: |
          if ( value && !this.animating ) {
             this.future( 0.1 ).animate();
          }
          this.animating = value;
        value: false
    children:
      goal2:
        extends: http://vwf.example.com/node3.vwf 
        properties:
          translation: [ 0, 0, 1500 ]
      planeGroup2:
        extends: http://vwf.example.com/node3.vwf 
        properties:
          translation: [ 0, 0, 1500 ]
        children:
          plane2:
            extends: http://vwf.example.com/node3.vwf
            source: models/Predator.dae
            type: model/vnd.collada+xml
            properties:
              translation: [ 0, 500, 1800 ]
              scale: [ 15, 15, 15 ]
          cone2:
            extends: http://vwf.example.com/node3.vwf
            source: models/cone.dae
            type: model/vnd.collada+xml
            properties:
              translation: [ 0, -300, -1100 ]
              scale: [ 8, 8, 16 ]
scripts:
- |
    this.initialize = function() {
      this.nodesCreated = [];

      // Wait until the queue resumes to set the mouse mode, so that we are sure that the camera has been 
      // created
      // TODO: When we can assume that initialize doesn't complete until all created nodes are in place, this
      //       will no longer need to be a future call because we will be able to assume that the camera exists
      this.future( 0 ).initializeInputMode();
      this.future( 0 ).initializeCamera();
    }
    this.initializeCamera = function() {
      this.camera.translation = [ 0, 20000, 10000 ];
      this.camera.far = 500000;
      this.camera.near = 2;
      this.camera.lookAt = this.children.sceneCenter.id;
    }
    this.toolbar.selectedColorChanged = this.events.add( function( color ) {
    }, this );
    this.toolbar.events.clearing = this.events.add( function() { 
      this.clear(); 
    }, this );
    var line = {
      "extends": "http://vwf.example.com/node3.vwf",
      "type": "definition/mesh",
      "properties": { 
        "meshDefinition": { positions: [], faces: [], color: [] }
      }
    };
    var cube = {
      "extends": "http://vwf.example.com/node3.vwf",
      "type": "definition/mesh",
      "properties": { 
        "meshDefinition": { positions: [], faces: [], color: [] }
      }
    }; 
    var cone = {
      "extends": "http://vwf.example.com/node3.vwf",
      "type": "definition/mesh",
      "properties": { 
        "meshDefinition": { positions: [], faces: [], color: [] }
      }
    };
    var pushpin = {
      extends: "http://vwf.example.com/node3.vwf",
      source: "models/pushpinblack.dae",
      type: "model/vnd.collada+xml",
      properties: { 
        positions: [],
        scale: [ 6, 6, 6.6 ], 
      },    
    };
    this.initializeInputMode = function() {
      this.inputMode = "orbit";
    }
    this.draw = function( lastDrawPoint, pickInfo ) {
      if ( pickInfo && pickInfo.globalPosition ) {
        if ( lastDrawPoint ) {
          var start = lastDrawPoint.pickInfo.globalPosition;
          var end = pickInfo.globalPosition;
          var sp = goog.vec.Vec3.createFromArray( [ start[0], start[1], start[2] + this.lineHeight ] );
          var ep = goog.vec.Vec3.createFromArray( [ end[0], end[1], end[2] + this.lineHeight ] );
           
          var pos = [];
          var faces;
          
          var diff = goog.vec.Vec3.createFromArray( [ ep[0] - sp[0], ep[1] - sp[1], ep[2] - sp[2] ] );
          var up = goog.vec.Vec3.createFromArray( [ 0, 1, 0 ] );
          var right = goog.vec.Vec3.createFromArray( [ 1, 0, 0 ] );
          var top = goog.vec.Vec3.createFromArray( [ 0, 0, 0 ] );
          
          goog.vec.Vec3.normalize( diff, diff );

          if ( Math.abs( goog.vec.Vec3.dot( up, diff, goog.vec.Vec3.create() ) ) < .999 ) // diff far enough from up? (.999==2.5 degrees)
          { // then we can cross with up
            goog.vec.Vec3.cross( diff, up, right );
          }
          else
          { //too colinear with up, so start w/ a different axis
            goog.vec.Vec3.cross( diff, right, right );
          }
          top = goog.vec.Vec3.cross( diff, right, top );
          goog.vec.Vec3.normalize( right, right );
          goog.vec.Vec3.normalize( top, top );
          goog.vec.Vec3.scale( right, this.lineWidth, right );
          goog.vec.Vec3.scale( top, this.lineWidth, top );              
          
          pos.push( sp[0] + right[0] );  // 0
          pos.push( sp[1] + right[1] );  // 0
          pos.push( sp[2] + right[2] );  // 0
          
          pos.push( ep[0] + right[0] );  // 1
          pos.push( ep[1] + right[1] );  // 1
          pos.push( ep[2] + right[2] );  // 1
          
          pos.push( sp[0] - right[0] );  // 2
          pos.push( sp[1] - right[1] );  // 2
          pos.push( sp[2] - right[2] );  // 2
          
          pos.push( ep[0] - right[0] );  // 3
          pos.push( ep[1] - right[1] );  // 3
          pos.push( ep[2] - right[2] );  // 3
          
          pos.push( sp[0] + top[0] );  // 4
          pos.push( sp[1] + top[1] );  // 4
          pos.push( sp[2] + top[2] );  // 4
          
          pos.push( ep[0] + top[0] );  // 5
          pos.push( ep[1] + top[1] );  // 5
          pos.push( ep[2] + top[2] );  // 5
          
          pos.push( sp[0] - top[0] );  // 6
          pos.push( sp[1] - top[1] );  // 6
          pos.push( sp[2] - top[2] );  // 6
          
          pos.push( ep[0] - top[0] );  // 7
          pos.push( ep[1] - top[1] );  // 7
          pos.push( ep[2] - top[2] );  // 7
          
          faces = [ 0, 1, 3, 0, 3, 2, 4, 5, 7, 4, 7, 6 ];
          
          var newLine = $.extend(true, {}, line);
          newLine.properties.meshDefinition.positions = pos;
          newLine.properties.meshDefinition.faces = faces;
          newLine.properties.meshDefinition.color = this.lineColor;
          
          this.children.create( "line"+this.lineIndex, newLine, function( newObj ) {
            this.nodesCreated.push( newObj.id );
            this.nodesCreated = this.nodesCreated;
          } );

          this.lineIndex++;
        }
        
      }
    }
    this.pindrop = function( pickInfo ) {
      
      if ( pickInfo && pickInfo.globalPosition ) {
        pushpin.properties.translation = pickInfo.globalPosition;
        
        if ( this.lineColor[0] == 255 && this.lineColor[1] == 0 && this.lineColor[2] == 0 ) 
          pushpin.source = "models/pushPinRed.dae";
        else if ( this.lineColor[0] == 0 && this.lineColor[1] == 255 && this.lineColor[2] == 0 ) 
          pushpin.source = "models/pushPinGreen.dae";
        else if ( this.lineColor[0] == 0 && this.lineColor[1] == 0 && this.lineColor[2] == 255 ) 
          pushpin.source = "models/pushPinBlue.dae";
        else if ( this.lineColor[0] == 0 && this.lineColor[1] == 0 && this.lineColor[2] == 0 ) 
          pushpin.source = "models/pushPinBlack.dae";
        else 
          pushpin.source = "models/pushPinYellow.dae";
        
        var name = "pushpin"+this.pushpinIndex;
        this.children.create( name, pushpin, function( newObj ) {
          this.nodesCreated.push( newObj.id );
          this.nodesCreated = this.nodesCreated;
        } );

        this.pushpinIndex++;        
        
        //var pt = parms.pickInfo.coord;
        //var dim = this.objScale;
        //this.createCube( pt[0], pt[1], pt[2]+this.lineHeight+(dim*0.3), dim, dim, dim, this.lineColor, true );
        //this.createCone( pt[0], pt[1], pt[2]+this.lineHeight+(dim*0.3), (dim*0.3), dim, this.lineColor, 18, true );
        //this.createLine( pt[0], pt[1], pt[2]+this.lineHeight+(dim*0.3), pt[0], pt[1], pt[2], this.lineWidth*0.3, [ 0, 0, 0 ], true );
      }
    }
    this.createCube = function( x, y, z, dx, dy, dz, color, temp ) {
      var pos = [];
      var faces;
      
      pos.push( x + ( 0.5 * dx ) );
      pos.push( y + ( 0.5 * dy ) );  // 0
      pos.push( z + ( 0.5 * dz ) );
      
      pos.push( x + ( -0.5 * dx ) );
      pos.push( y + ( 0.5 * dy ) );  // 1
      pos.push( z + ( 0.5 * dz ) );
      
      pos.push( x + ( -0.5 * dx ) );
      pos.push( y + ( -0.5 * dy ) ); // 2
      pos.push( z + ( 0.5 * dz ) ); 
      
      pos.push( x + ( 0.5 * dx ) );
      pos.push( y + ( -0.5 * dy ) ); // 3
      pos.push( z + ( 0.5 * dz ) );
      
      pos.push( x + ( 0.5 * dx ) );
      pos.push( y + ( 0.5 * dy ) ); // 4
      pos.push( z + ( -0.5 * dz ) );
      
      pos.push( x + ( -0.5 * dx ) );
      pos.push( y + ( 0.5 * dy ) );  // 5
      pos.push( z + ( -0.5 * dz ) );
      
      pos.push( x + ( -0.5 * dx ) );
      pos.push( y + ( -0.5 * dy ) );  // 6
      pos.push( z + ( -0.5 * dz ) );
      
      pos.push( x + ( 0.5 * dx ) );
      pos.push( y + ( -0.5 * dy ) ); // 7
      pos.push( z + ( -0.5 * dz ) );      
      
      faces = [ 1, 0, 3, 1, 3, 2, 3, 0, 4, 3, 4, 7, 2, 3, 7, 2, 7, 6, 6, 7, 4, 6, 4, 5, 1, 2, 6, 1, 6, 5, 0, 1, 5, 0, 5, 4 ];

      cube.properties.meshDefinition.positions = pos;
      cube.properties.meshDefinition.faces = faces;
      cube.properties.meshDefinition.color = color;
      
      this.children.create( "cube"+this.cubeIndex, cube, function( newObj ) {
        if ( temp ) {
          this.nodesCreated.push( newObj.id );
          this.nodesCreated = this.nodesCreated;
        }
      } );

      this.cubeIndex++;
    }
    this.createLine = function( x1, y1, z1, x2, y2, z2, thickness, color, temp ) {
      var pos = [];
      var faces;
      
      var diff = goog.vec.Vec3.createFromArray( [ x2 - x1, y2 - y1, z2 - z1 ] );
      var up = goog.vec.Vec3.createFromArray( [ 0, 1, 0 ] );
      var right = goog.vec.Vec3.createFromArray( [ 1, 0, 0 ] );
      var top = goog.vec.Vec3.createFromArray( [ 0, 0, 0 ] );
      
      goog.vec.Vec3.normalize( diff, diff );

      if ( Math.abs( goog.vec.Vec3.dot( up, diff, goog.vec.Vec3.create() ) ) < .999 ) // diff far enough from up? (.999==2.5 degrees)
      { // then we can cross with up
        goog.vec.Vec3.cross( diff, up, right );
      }
      else
      { //too colinear with up, so start w/ a different axis
        goog.vec.Vec3.cross( diff, right, right );
      }
      goog.vec.Vec3.cross( diff, right, top );
      goog.vec.Vec3.normalize( right, right );
      goog.vec.Vec3.normalize( top, top );
      goog.vec.Vec3.scale( right, thickness, right );
      goog.vec.Vec3.scale( top, thickness, top );              
      
      pos.push( x1 + right[0] );  // 0
      pos.push( y1 + right[1] );  // 0
      pos.push( z1 + right[2] );  // 0
      
      pos.push( x2 + right[0] );  // 1
      pos.push( y2 + right[1] );  // 1
      pos.push( z2 + right[2] );  // 1
      
      pos.push( x1 - right[0] );  // 2
      pos.push( y1 - right[1] );  // 2
      pos.push( z1 - right[2] );  // 2
      
      pos.push( x2 - right[0] );  // 3
      pos.push( y2 - right[1] );  // 3
      pos.push( z2 - right[2] );  // 3
      
      pos.push( x1 + top[0] );  // 4
      pos.push( y1 + top[1] );  // 4
      pos.push( z1 + top[2] );  // 4
      
      pos.push( x2 + top[0] );  // 5
      pos.push( y2 + top[1] );  // 5
      pos.push( z2 + top[2] );  // 5
      
      pos.push( x1 - top[0] );  // 6
      pos.push( y1 - top[1] );  // 6
      pos.push( z1 - top[2] );  // 6
      
      pos.push( x2 - top[0] );  // 7
      pos.push( y2 - top[1] );  // 7
      pos.push( z2 - top[2] );  // 7
      
      faces = [ 0, 1, 3, 0, 3, 2, 4, 5, 7, 4, 7, 6 ];
      
      line.properties.meshDefinition.positions = pos;
      line.properties.meshDefinition.faces = faces;
      line.properties.meshDefinition.color = color;
      
      this.children.create( "line"+this.lineIndex, line, function( newObj ) {
        if ( temp ) {
          this.nodesCreated.push( newObj.id );
          this.nodesCreated = this.nodesCreated;
        }
      } );

      this.lineIndex++;    
    }
    this.createCone = function( x, y, z, radius, height, color, accuracy, temp ) {
      var pos = [];
      var faces = [];
      var pt = 1;
      
      pos.push( x );
      pos.push( y );
      pos.push( z + height );      
      
      for ( var theta = 0; theta <= 2 * Math.PI; theta += Math.PI / accuracy ) {
        pos.push( x + ( radius * Math.cos( theta ) ) );
        pos.push( y + ( radius * Math.sin( theta ) ) );
        pos.push( z );
        pos.push( x + ( radius * Math.cos( theta - Math.PI / accuracy ) ) );
        pos.push( y + ( radius * Math.sin( theta - Math.PI / accuracy ) ) );
        pos.push( z );
        
        faces.push( 0 );
        faces.push( pt );
        faces.push( pt + 1 );
        pt += 2;
      }
      cone.properties.meshDefinition.positions = pos;
      cone.properties.meshDefinition.faces = faces;
      cone.properties.meshDefinition.color = color;
      
      this.children.create( "cone"+this.coneIndex, cone, function( newObj ) {
        if ( temp ) {
          this.nodesCreated.push( newObj.id );
          this.nodesCreated = this.nodesCreated;
        }
      } );

      this.coneIndex++; 
    } //@ sourceURL=index.vwf