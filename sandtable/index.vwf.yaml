--- 
extends: appscene.vwf
source: index.xml
type: model/x-glge
properties:
  ambientColor: [ 183, 183, 183 ]
  activeCamera: "http-vwf-example-com-types-camera-maincamera"
  backgroundColor: [ 83, 157, 194 ]
  loadDone: false
scripts:
- text: |
    this.initialize = function() {
      //console.info( "================ sandtable ================" );
      this.activeCamera = "http-vwf-example-com-types-camera-maincamera";
      this.loadDone = true;
      vwf.setProperty( "http-vwf-example-com-types-camera-maincamera", "lookAt", "http-vwf-example-com-types-node3-sceneCenter" );
    }
    this.toolbar.selectedColorChanged = this.events.add( function( color ) {
      // console.info( "selected color", color, this.toolbar.selectedColor );
    }, this );
    this.toolbar.inputModeChanged = this.events.add( function( mode ) {
      // console.info( "selected color", color, this.toolbar.selectedColor );
    }, this );
    this.toolbar.events.clearing = this.events.add( function() { 
      this.clear(); 
    }, this );
  type: application/javascript
children:
  toolbar:
    properties:
      selectedColor:
        set: |
          this.selectedColor = value;
          this.selectedColorChanged( value );
        value:
          "black"
      inputMode:
        set: |
          this.inputMode = value;
          this.inputModeChanged( value );
        value:
          "orbit"      
    methods:
      clear: |
        this.clearing();
    events:
      selectedColorChanged:
      inputModeChanged:
      clearing:
  flat_terrain:
    extends: http://vwf.example.com/types/node3
    source: models/vwf_terrain.dae
    type: model/vnd.collada+xml
    properties:
      position: [ 0, 0, -150 ]
      eulers: [0, 0, 0 ]
      scale: [ 0.008, 0.008, 0.020 ]
  sceneCenter:
    extends: http://vwf.example.com/types/node3
    properties:
      position: [ 0, 0, 0 ]
  maincamera:
    extends: http://vwf.example.com/types/camera
    properties:
      walkMode: "walk"
      cameraType: "perspective"
      position: [ 0, 20000, 10000 ]
      rotation: [ 1.56, 3.14, 0 ]
      far: 500000
      near: 2
      lookAt: "http-vwf-example-com-types-node3-sceneCenter"
    scripts:
    - text: |
        this.initialize = function() {
          this.lookAt = "http-vwf-example-com-types-node3-sceneCenter";
        }
      type: application/javascript      
  light1:
    extends: http://vwf.example.com/types/light
    properties:
      lightType: "point"
      constantAttenuation: 1
  predator1:
    extends: http://vwf.example.com/types/node3 
    methods:
      animate: |
        //console.info( "== predator1 ===== animate ================" );
        var time = vwf.time();
        var len = this.path.length;
        var timeElasped = time - this.timeSinceLast;
        var lastPathPoint = this.path[ this.lastPathIndex ];
        var nextPathPoint = this.path[ this.nextPathIndex ];
        var goalPointIndex = this.nextPathIndex + 1;
        if ( goalPointIndex >= this.path.length )
          goalPointIndex = 0;
        var goalPathPoint = this.path[ goalPointIndex ];
        var percentDone = timeElasped / nextPathPoint.time;
        if ( percentDone > 0.975 )
          percentDone = 1;
       
        function interpolate( beforeCoord, afterCoord, percent ) {
          return beforeCoord + percent * (afterCoord - beforeCoord);
        }
        
        var newX = interpolate( nextPathPoint.position[0], goalPathPoint.position[0], percentDone );
        var newY = interpolate( nextPathPoint.position[1], goalPathPoint.position[1], percentDone );
        this.goal1.position = [ newX, newY, 1200 ]; 
        
        newX = interpolate( lastPathPoint.position[0], nextPathPoint.position[0], percentDone );
        newY = interpolate( lastPathPoint.position[1], nextPathPoint.position[1], percentDone );
        this.planeGroup1.position = [ newX, newY, 1200 ];
        
        var zRot = [ goalPathPoint.position[0] - newX, goalPathPoint.position[1] - newY, 0 ];
        var sq = zRot[0] * zRot[0] + zRot[1] * zRot[1];
        var vecLen = ( sq > 0 ) ? Math.pow( sq, 0.5 ) : 0.0;
        zRot[0] /= vecLen;
        zRot[1] /= vecLen;
        this.planeGroup1.rotation = [ 0, 0, Math.acos( zRot[0] ) ]; 
        
        if ( percentDone == 1 ) {
          this.lastPathIndex += 1;
          this.timeSinceLast = time;
        }
        if ( this.animating ) {
          this.future( 0.1 ).animate();
        }   
    scripts:
      - text: |
          this.initialize = function() {
            console.info( "================ predator1 ================" );

            this.path = [];
            var len = 0, pos, x, y, z = 1200;
            
            for ( var theta = 0; theta < 2 * Math.PI && len < (( 2*180 )-1); theta += Math.PI / 180 ) {
              x = 10000 * Math.cos( theta );
              y = 10000 * Math.sin( theta );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { position: pos, time: 1 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }  
            
            this.nextPathIndex = this.lastPathIndex+1;
            this.timeSinceLast = vwf.time();
            this.planeGroup1.position = this.path[ this.lastPathIndex ].position;
            this.goal1.position = this.path[ this.nextPathIndex ].position;
           
            this.animating = true;
          }
        type: application/javascript 
    properties:
      position: [ 0, 0, 1200 ]
      eulers: [0, 0, 0 ]
      scale: [ 1, 1, 1 ] 
      lastPathIndex:
        set: |
          // console.info( "predator1.lastPathIndex.set   value = " + value );
          if ( value >= 0 ) {
            if ( value < this.path.length ) {
              this.lastPathIndex = value;
              this.nextPathIndex = value+1;
              if ( this.nextPathIndex == this.path.length )
                this.nextPathIndex = 0;
            } else {
              this.lastPathIndex = 0;
              this.nextPathIndex = 1;              
            }
          }
        value: 0
      animating:
        set: |
          if ( value && !this.animating ) {
             this.future( 0.1 ).animate();
          }
          this.animating = value;
        value: false
    children:
      goal1:
        extends: http://vwf.example.com/types/node3 
        properties:
          position: [ 0, 0, 1200 ]
          eulers: [0, 0, 0 ]
          scale: [ 1, 1, 1 ]      
      planeGroup1:
        extends: http://vwf.example.com/types/node3 
        properties:
          position: [ 0, 0, 1200 ]
          eulers: [0, 0, 0 ]
          scale: [ 1, 1, 1 ]
        children:
          plane1:
            extends: http://vwf.example.com/types/node3
            source: models/Predator.dae
            type: model/vnd.collada+xml
            properties:
              position: [ 0, 500, 1800 ]
              rotation: [0, 0, -1.57 ]
              scale: [ 15, 15, 15 ]
          cone1:
            extends: http://vwf.example.com/types/node3
            source: models/cone.dae
            type: model/vnd.collada+xml
            properties:
              position: [ 0, -300, -1100 ]
              eulers: [0, 0, 0 ]
              scale: [ 8, 8, 16 ]
  predator2:
    extends: http://vwf.example.com/types/node3 
    methods:
      animate: |
        //console.info( "== predator2 =====  animate ================" );
        var time = vwf.time();
        var len = this.path.length;
        var timeElasped = time - this.timeSinceLast;
        var lastPathPoint = this.path[ this.lastPathIndex ];
        var nextPathPoint = this.path[ this.nextPathIndex ];
        var goalPointIndex = this.nextPathIndex + 1;
        if ( goalPointIndex >= this.path.length )
          goalPointIndex = 0;
        var goalPathPoint = this.path[ goalPointIndex ];
        var percentDone = timeElasped / nextPathPoint.time;
        if ( percentDone > 0.975 )
          percentDone = 1;
      
        function interpolate( beforeCoord, afterCoord, percent ) {
          return beforeCoord + percent * (afterCoord - beforeCoord);
        }
        
        var newX = interpolate( nextPathPoint.position[0], goalPathPoint.position[0], percentDone );
        var newY = interpolate( nextPathPoint.position[1], goalPathPoint.position[1], percentDone );
        this.goal2.position = [ newX, newY, 1200 ]; 
        
        newX = interpolate( lastPathPoint.position[0], nextPathPoint.position[0], percentDone );
        newY = interpolate( lastPathPoint.position[1], nextPathPoint.position[1], percentDone );
        this.planeGroup2.position = [ newX, newY, 1200 ];
 
        var zRot = [ goalPathPoint.position[0] - newX, goalPathPoint.position[1] - newY, 0 ];
        var sq = zRot[0] * zRot[0] + zRot[1] * zRot[1];
        var vecLen = ( sq > 0 ) ? Math.pow( sq, 0.5 ) : 0.0;
        zRot[0] /= vecLen;
        zRot[1] /= vecLen;
        //console.info( " this.planeGroup2.rotation.Z = " + Math.acos( zRot[0] ) );
        this.planeGroup2.rotation = [ 0, 0, Math.acos( zRot[0] ) ];
 
        if ( percentDone == 1 ) {
          this.lastPathIndex += 1;
          
          var newPt = this.path[ this.lastPathIndex ].position;
          var goalPt = this.path[ this.nextPathIndex ].position;
          
          //console.info( "== UPDATING ================================================" );
          //console.info( "== this.path[ "+this.lastPathIndex+" ] = [ " + newPt[0] + ", " + newPt[1] + ", " + newPt[2] + " ] ==" );
          //console.info( "== this.path[ "+this.nextPathIndex+" ] = [ " + goalPt[0] + ", " + goalPt[1] + ", " + goalPt[2] + " ] ==" );
          //console.info( "============================================================" );
          
          //console.info( "============================================================" );
          
          this.timeSinceLast = time;
        }
        if ( this.animating ) {
          this.future( 0.1 ).animate();
        }   
    scripts:
      - text: |
          this.initialize = function() {
            console.info( "================ predator2 ================" );

            this.path = [];
            var len, pos, x = 0, y = 0, z = 12000;
            var radius = 5000;
            var step = 200;
            
            y = 0;
            //console.info( "START X === " + radius + " to -" + radius );
            for ( var x = radius - 200; x > -radius; x -= step ) {
              pos = [ x, 0, 1200 ];
              len = this.path.length;
              this.path.push( { position: pos, time: 1 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }
            //console.info( "END X === " + radius + " to -" + radius );
            
            
            //console.info( "START -X +Y === 270 to 90" );
            for ( var theta = 1.5 * Math.PI; theta > 0; theta -= Math.PI / 90 ) {
              x = -radius + ( radius * Math.cos( theta ) );
              y = radius + ( radius * Math.sin( theta ) );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { position: pos, time: 2 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            } 
            //console.info( "END -X +Y === 270 to 90" );
  
            x = 0;
            //console.info( "START Y === " + radius + " to -" + radius );
            for ( var y = radius - step; y > -radius ; y -= step ) {
              pos = [ 0, y, 1200 ];
              len = this.path.length;
              this.path.push( { position: pos, time: 1 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }
            //console.info( "END Y === " + radius + " to -" + radius );

            //console.info( "START -X -Y === 0 to 90" );
            for ( var theta = 2 * Math.PI; theta > 0.5 * Math.PI; theta -= Math.PI / 90 ) {
              x = -radius + (radius * Math.cos( theta ) );
              y = -radius + (radius * Math.sin( theta ) );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { position: pos, time: 2 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            } 
            //console.info( "END -X -Y === 0 to 90" );

            y = 0;
            //console.info( "START X === -" + radius + " to " + radius );
            for ( var x = -radius + step; x < radius; x += step ) {
              pos = [ x, 0, 1200 ];
              len = this.path.length;
              this.path.push( { position: pos, time: 1 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }            
            //console.info( "END X === -" + radius + " to " + radius );
 
            //console.info( "START +X +Y === 270 to 180" );
            for ( var theta = 1.5 * Math.PI; theta < 3.0 * Math.PI; theta += Math.PI / 90 ) {
              x = radius + (radius * Math.cos( theta ) );
              y = radius + (radius * Math.sin( theta ) );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { position: pos, time: 2 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }
            //console.info( "END +X +Y === 270 to 180" );
            
            x = 0;
            //console.info( "START Y === " + radius + " to -" + radius );
            for ( var y = radius - step; y > -radius; y -= step ) {
              pos = [ 0, y, 1200 ];
              len = this.path.length;
              this.path.push( { position: pos, time: 1 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }
            //console.info( "END Y === " + radius + " to -" + radius );

            //console.info( "START +X -Y === 180 to 90" );
            for ( var theta = 1.0 * Math.PI; theta < 2.5 * Math.PI; theta += Math.PI / 90 ) {
              x = radius + ( radius * Math.cos( theta ) );
              y = -radius + ( radius * Math.sin( theta ) );
              len = this.path.length;
              pos = [ x, y, z ];
              this.path.push( { position: pos, time: 2 } );
              //console.info( "   this.path["+len+"] = [ " + x + ", " + y + ", " + z + " ]" );
            }            
            //console.info( "END +X -Y === 180 to 90" );
           
            this.nextPathIndex = this.lastPathIndex+1;
            this.timeSinceLast = vwf.time();
            this.planeGroup2.position = this.path[ this.lastPathIndex ].position;
            this.goal2.position = this.path[ this.nextPathIndex ].position;
            //this.planeGroup2.plane2.lookAt = "http-vwf-example-com-types-node3-goal2";
            //this.planeGroup2.cone2.lookAt = "http-vwf-example-com-types-node3-goal2";
            
            this.animating = true;
          }
        type: application/javascript 
    properties:
      position: [ 0, 0, 1500 ]
      eulers: [0, 0, 0 ]
      scale: [ 1, 1, 1 ] 
      lastPathIndex:
        set: |
          // console.info( "predator2.lastPathIndex.set   value = " + value );
          if ( value >= 0 ) {
            if ( value < this.path.length ) {
              this.lastPathIndex = value;
              this.nextPathIndex = value+1;
              if ( this.nextPathIndex == this.path.length )
                this.nextPathIndex = 0;
            } else {
              this.lastPathIndex = 0;
              this.nextPathIndex = 1;              
            }
          }
        value: 0
      animating:
        set: |
          if ( value && !this.animating ) {
             this.future( 0.1 ).animate();
          }
          this.animating = value;
        value: false
    children:
      goal2:
        extends: http://vwf.example.com/types/node3 
        properties:
          position: [ 0, 0, 1500 ]
          eulers: [0, 0, 0 ]
          scale: [ 1, 1, 1 ]      
      planeGroup2:
        extends: http://vwf.example.com/types/node3 
        properties:
          position: [ 0, 0, 1500 ]
          eulers: [0, 0, 0 ]
          scale: [ 1, 1, 1 ]
        children:
          plane2:
            extends: http://vwf.example.com/types/node3
            source: models/Predator.dae
            type: model/vnd.collada+xml
            properties:
              position: [ 0, 500, 1800 ]
              rotation: [0, 0, -1.57 ]
              scale: [ 15, 15, 15 ]
          cone2:
            extends: http://vwf.example.com/types/node3
            source: models/cone.dae
            type: model/vnd.collada+xml
            properties:
              position: [ 0, -300, -1100 ]
              eulers: [0, 0, 0 ]
              scale: [ 8, 8, 16 ]
