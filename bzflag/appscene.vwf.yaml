# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

---
extends: http://vwf.example.com/scene.vwf
properties:

  ## The size of the VWF world
  ## 
  ## @name appscene.vwf#worldSize
  ## @property

  worldSize: 137472

  ## The size of the collision map image in pixels
  ## 
  ## @name appscene.vwf#collisionMapSize
  ## @property

  collisionMapSize: 525

  ## World size / collision map size
  ## 
  ## @name appscene.vwf#collisionMapScaleFactor
  ## @property

  collisionMapScaleFactor: 262

  ## The relative path to the image used for the collision map
  ## 
  ## @name appscene.vwf#collisionMapPath
  ## @property

  collisionMapPath: images/bzworldcollisionmap.png

methods:
  update: 
scripts:
- |
  var collisionMapCanvas, collisionMapContext, collisionMapImageData;

  this.initialize = function() {
    collisionMapCanvas = document.createElement('canvas');
    collisionMapCanvas.width = this.collisionMapSize;
    collisionMapCanvas.height = this.collisionMapSize;
    collisionMapContext = collisionMapCanvas.getContext("2d");
    var collisionMapImage = new Image();
    collisionMapImage.onload = function() {
        collisionMapContext.drawImage(collisionMapImage, 0, 0);
        collisionMapImageData = collisionMapContext.getImageData(0, 0, collisionMapCanvas.width, collisionMapCanvas.height);
    }
    collisionMapImage.src = this.collisionMapPath;
  }
  this.collisionDetection = function(deltaTranslation, player) {
    var collision = false;
    var playerBoundingBox = player.cachedBoundingBox;
    playerBoundingBox.max.x += deltaTranslation[0];
    playerBoundingBox.min.x += deltaTranslation[0];
    playerBoundingBox.max.y += deltaTranslation[1];
    playerBoundingBox.min.y += deltaTranslation[1];
    playerBoundingBox.max.z += deltaTranslation[2];
    playerBoundingBox.min.z += deltaTranslation[2];

    collision = this.checkForStaticCollision(playerBoundingBox) ||
        this.checkForDynamicCollision(player, playerBoundingBox, this.players.children);
    return collision;
  }
  this.checkForStaticCollision = function(playerBoundingBox) {
    var minX, minY, maxX, maxY;
    var worldSize = this.worldSize / 2;
    
    minX = ((playerBoundingBox.min.x + worldSize) / this.collisionMapScaleFactor) | 0;
    minY = ((worldSize - playerBoundingBox.min.y) / this.collisionMapScaleFactor) | 0;
    maxX = ((playerBoundingBox.max.x + worldSize) / this.collisionMapScaleFactor) | 0;
    maxY = ((worldSize - playerBoundingBox.max.y) / this.collisionMapScaleFactor) | 0;

    if(minX < 0 || minY < 0 || maxX > this.collisionMapSize || maxY > this.collisionMapSize) {
      return this.bz_world;
    }
    else {
      if(collisionMapImageData.data[4 * (minX + 525 * minY) + 3] != 0) {
        return this.bz_world;
      }
      if(collisionMapImageData.data[4 * (minX + 525 * maxY) + 3] != 0) {
        return this.bz_world;
      }
      if(collisionMapImageData.data[4 * (maxX + 525 * minY) + 3] != 0) {
        return this.bz_world;
      }
      if(collisionMapImageData.data[4 * (maxX + 525 * maxY) + 3] != 0) {
        return this.bz_world;
      }
    }
    return false;
  }
  this.checkForDynamicCollision = function(player, playerBoundingBox, sceneObjects) {
    for(var i=0;i<sceneObjects.length;i++) {
      if(player.id != sceneObjects[i].id && (!player.parentTank || player.parentTank != sceneObjects[i].id) && sceneObjects[i].active != false) {
        var sceneBoundingBox = sceneObjects[i].cachedBoundingBox ? sceneObjects[i].cachedBoundingBox : sceneObjects[i].worldBoundingBox;
        if(sceneBoundingBox.max.x == Infinity || sceneBoundingBox.max.y == Infinity || sceneBoundingBox.max.z == Infinity || 
            sceneBoundingBox.min.x == -Infinity || sceneBoundingBox.min.y == -Infinity || sceneBoundingBox.min.z == -Infinity) {
          continue;
        }
        if(playerBoundingBox.max.x < sceneBoundingBox.min.x || playerBoundingBox.min.x > sceneBoundingBox.max.x ||
              playerBoundingBox.max.y < sceneBoundingBox.min.y || playerBoundingBox.min.y > sceneBoundingBox.max.y || 
              playerBoundingBox.max.z < sceneBoundingBox.min.z || playerBoundingBox.min.z > sceneBoundingBox.max.z) {
          continue;
        }
        return sceneObjects[i];
      }
    }
    return false;
  }
